# Algorithms and Complexity 
---
> [!info]+ Module Details
> Contains details on this (genus:: Module) from [Year::2]: Module tag, Teacher tags and Resources 
> > *Module :*  [[Algorithms & Complexity]]
> > *Teacher*: 
> > *Resources :*



---
> [!abstract]+ Contents
> List of links to notes on Topics within the Module
> 
> sub grouping
> > [[#]]
> [[#]]
> [[#]]
> > [[#]]
> 
> Coursework
> > [[]]

---
### Coursework 25 vs 75 Examed
- Set exercises individual (CWSI 25%)
	**Details** - 
- Closed-book written examination (EXCB 75%)
	**Details** - 
---
### Course Description

> [!info]+  Course Description
> 
|                        | Content        |
| ---------------------- | -------------- |
| **Learning Outcomes:** | 1. describe the fundamental models of computation and the corresponding classes of formal grammars and languages;<br>2. design algorithms for specific computational problems as automata of appropriate types;<br>3. prove mathematically that some computational problems are undecidable within a particular class of computational models;<br>4. determine the complexity of a variety of algorithms;<br>5. describe a variety of data structures and algorithms and choose appropriate ones for solving a given computational problem;<br>6. for a variety of algorithms, demonstrate their correctness in certain respects.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **Synopsis:**          | You will explore fundamental models of computation such as finite automata and Turing machines, design algorithms within a given model, and formally prove that a problem cannot be addressed within a given model. You will learn about a variety of data structures and choose an appropriate one for a given problem. You will determine the computational complexity of algorithms and demonstrate their correctness.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| **Content:**           | Regular languages; deterministic and non-deterministic finite automata; existence of non-regular languages via the Pumping Lemma. Context-free languages; pushdown automata; context-free grammars; parsing in context-free languages; existence of non-context-free languages via the Pumping Lemma. Turing machines; Church-Turing Thesis; Universal Turing machine and undecidability of the halting problem. Non-deterministic Turing machines; complexity classes $P$ and $NP$; $P$ vs $NP$ problem. Data structures such as lists, stacks, queues, trees, hash tables, heaps, graphs, and self-balancing trees. Methods of designing efficient algorithms such as divide-and-conquer, recursion, dynamic programming, and greedy algorithms. Complexity; best, worst and average cases; time, space and other measures; $big$ $Ο$, $big$ $\Theta$<br>and $big$ $Ω$ notation. Analysis of algorithms such as sorting algorithms, graph algorithms, and algorithms for linear algebra. Basic correctness techniques including loop invariants. Algorithms and data structures in practice; crossover points between algorithms; polyalgorithms; computationally hard problems in everyday life. |


